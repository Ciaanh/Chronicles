# Chronicles Addon - Code Development Context

## When working on Chronicles addon code, follow these specific guidelines

### Addon Namespace and Globals

- Main addon namespace: `private.Chronicles` (using AceAddon-3.0)
- Private namespace: `private` (contains all core systems)
- Saved variables: `ChroniclesDB` (managed by AceDB-3.0)
- Always use the private namespace for internal systems: `private.Core.*`
- Addon uses LibStub and AceAddon-3.0 framework

### WoW API Integration Patterns

#### Event Registration

```lua
-- Modern event system using private.Core with centralized constants
local events = private.constants.events -- Use local reference for cleaner code

private.Core.registerCallback(
    events.EventSelected,
    function(eventData)
        -- Handle event selection
        private.Core.StateManager.setState("ui.selectedEvent", eventData, "Event selected")
    end,
    "ModuleName"
)

-- Traditional WoW event registration (still supported)
local frame = CreateFrame("Frame")
frame:RegisterEvent("ADDON_LOADED")
frame:SetScript("OnEvent", function(self, event, ...)
    if event == "ADDON_LOADED" then
        local addonName = ...
        if addonName == "Chronicles" then
            -- Initialization code here
            self:UnregisterEvent("ADDON_LOADED")
        end
    end
end)

-- Triggering custom events using centralized constants
private.Core.triggerEvent(events.TimelineInit, nil, "ModuleName")
```

#### Frame Management

```lua
-- Always parent frames properly
local frame = CreateFrame("Frame", "ChroniclesMainFrame", UIParent, "UIPanelDialogTemplate")

-- Use proper frame lifecycle
frame:SetScript("OnShow", function(self)
    -- Show logic
end)
frame:SetScript("OnHide", function(self)
    -- Hide logic
end)
```

### Data Access Patterns

#### Logger System Usage

```lua
-- Use the private Core Logger system
private.Core.Logger.debug("ModuleName", "Loading timeline data for " .. expansionName)
private.Core.Logger.info("ModuleName", "Timeline UI initialized successfully")
private.Core.Logger.warn("ModuleName", "Missing localization for key: " .. key)
private.Core.Logger.error("ModuleName", "Failed to load event data: " .. tostring(err))

-- Available log levels: trace, debug, info, warn, error, fatal
-- Logger configuration is in private.Core.Logger with color coding
-- Log history is maintained automatically with configurable size limit
```

#### State Management

```lua
-- Use private Core StateManager for persistent data
local lastSelectedExpansion = private.Core.StateManager.getState("ui.selectedExpansion") or "CLASSIC"
private.Core.StateManager.setState("ui.selectedExpansion", selectedExpansion, "User selection changed")

-- Subscribe to state changes
private.Core.StateManager.subscribe("ui.selectedEvent", function(newValue, oldValue, path)
    -- Handle state change
end, "ModuleName")

-- AceDB-3.0 integration (automatic via Chronicles.db)
-- State persistence is handled automatically by StateManager
private.Core.StateManager.saveState() -- Manual save if needed
private.Core.StateManager.loadState() -- Manual load if needed
```

#### Data Loading

```lua
-- Chronicles.Data manages all data access
-- Event data registration
Chronicles.Data:RegisterEventDB(libraryName, eventsDB)
Chronicles.Data:RegisterCharacterDB(libraryName, charactersDB)
Chronicles.Data:RegisterFactionDB(libraryName, factionsDB)

-- Data access patterns
local events = Chronicles.Data:GetEvents()
local characters = Chronicles.Data:GetCharacters()
local factions = Chronicles.Data:GetFactions()

-- Status checking
local isActive = Chronicles.Data:GetEventDBStatus(libraryName)
Chronicles.Data:SetEventDBStatus(libraryName, false) -- Disable library
```

### UI Development Patterns

#### Template Usage

```lua
-- Use existing templates for consistency
local button = CreateFrame("Button", nil, parent, "ChroniclesEventButtonTemplate")
button:SetText(eventData.title)
button:SetScript("OnClick", function()
    Chronicles.UI:ShowEventDetails(eventData)
end)
```

#### Responsive Design

```lua
-- Scale-aware UI positioning
local scale = UIParent:GetEffectiveScale()
frame:SetPoint("CENTER", UIParent, "CENTER", 0, 0)
frame:SetSize(800 * scale, 600 * scale)
```

#### Localization Integration

```lua
-- Always use localized strings
button:SetText(Chronicles.L["SHOW_TIMELINE"])
tooltip:SetText(Chronicles.L["TOOLTIP_EVENT_DETAILS"])

-- Provide fallback for missing localizations
local text = Chronicles.L[key] or ("Missing: " .. key)
```

##### Localization Best Practices

1. All user-facing strings must have localization keys
2. Provide context comments for translators
3. Keep string keys descriptive and organized
4. Use consistent naming patterns across expansions

##### String Key Conventions

````lua
-- Event titles
Chronicles.L["EVENT_TITLE_ARTHAS_CORRUPTION"] = "The Corruption of Arthas"

-- Event descriptions
Chronicles.L["EVENT_DESC_ARTHAS_CORRUPTION"] = "Prince Arthas Menethil begins his descent into darkness..."

-- Character names (when localization is needed)
Chronicles.L["CHARACTER_ARTHAS"] = "Arthas Menethil"

-- Location names (when localization is needed)
Chronicles.L["LOCATION_ICECROWN"] = "Icecrown Citadel"

### Database Interaction Patterns

#### Event Data Structure

```lua
-- Standard event structure (matches actual implementation)
local eventData = {
    id = eventId, -- number
    label = "Event Title", -- string
    yearStart = -10000, -- number
    yearEnd = -9000, -- number
    chapters = {"Chapter 1", "Chapter 2"}, -- optional array
    eventType = "major", -- optional: "major", "minor", etc.
    factions = {"Alliance", "Horde"}, -- optional array
    characters = {"Thrall", "Jaina"}, -- optional array
    source = "Chronicles", -- optional string
    order = 1 -- optional number for ordering
}

-- Event validation is handled automatically by private.Core.EventManager.Validator
````

#### Data Registration and Management

```lua
-- Register data modules (done in ChroniclesDB.lua)
Chronicles.Data:RegisterEventDB("OriginsEvents", OriginsEventsDB)
Chronicles.Data:RegisterCharacterDB("OriginsCharacters", OriginsCharactersDB)
Chronicles.Data:RegisterFactionDB("OriginsFactions", OriginsFactionsDB)

-- Access registered data
local eventDBs = Chronicles.Data.Events
local characterDBs = Chronicles.Data.Characters
local factionDBs = Chronicles.Data.Factions

-- Check registration status
local isActive = Chronicles.Data:GetEventDBStatus("OriginsEvents")
Chronicles.Data:SetEventDBStatus("OriginsEvents", false) -- Disable
```

### Error Handling Best Practices

#### Safe API Calls

```lua
-- Protect against API changes
local function SafeGetGuildInfo()
    if GetGuildInfo then
        local guildName = GetGuildInfo("player")
        return guildName
    else
        Chronicles.Logger:Warn("GetGuildInfo API not available")
        return nil
    end
end
```

#### Data Validation

```lua
-- Validate event data before processing
local function ValidateEventData(eventData)
    if not eventData or type(eventData) ~= "table" then
        Chronicles.Logger:Error("Invalid event data: not a table")
        return false
    end

    if not eventData.id or not eventData.title then
        Chronicles.Logger:Error("Event missing required fields: id or title")
        return false
    end

    return true
end
```

### Performance Optimization

#### Memory Management

```lua
-- Clean up event handlers on hide
frame:SetScript("OnHide", function(self)
    -- Unregister events
    self:UnregisterAllEvents()
    -- Clear references
    self.eventData = nil
end)
```

#### Efficient Data Loading

```lua
-- Use coroutines for large data processing
local function LoadLargeDataset()
    local co = coroutine.create(function()
        for i, eventData in ipairs(largeEventList) do
            ProcessEvent(eventData)
            if i % 100 == 0 then
                coroutine.yield() -- Yield periodically
            end
        end
    end)

    local function ResumeLoading()
        if coroutine.status(co) ~= "dead" then
            coroutine.resume(co)
            C_Timer.After(0.01, ResumeLoading) -- Continue next frame
        end
    end

    ResumeLoading()
end
```

### Integration Patterns

#### RP Addon Integration

```lua
-- Safe integration with optional dependencies
local function GetRPProfile(unitName)
    if totalRP3 then
        -- totalRP3 integration
        return Chronicles.Integrations.TotalRP3:GetProfile(unitName)
    elseif MyRolePlay then
        -- MyRolePlay integration
        return Chronicles.Integrations.MyRolePlay:GetProfile(unitName)
    end
    return nil
end
```

### Debugging and Development

#### Debug Mode Support

```lua
-- Logger configuration for debugging
private.Core.Logger.setLogLevel("DEBUG") -- Enable debug logging
private.Core.Logger.setEnabled(true)

-- State debugging via console (still available)
-- /cstatedebug - Show current state
-- /cstatedebug history - Show state change history
-- /cstatedebug get <path> - Get specific state value
-- /cstatedebug set <path> <value> - Set specific state value

-- Error handling with automatic logging
local success, result = private.Core.Logger.safecall(
    function()
        -- risky operation
    end,
    "ModuleName",
    "Operation description"
)
```

#### Performance Profiling

```lua
-- Use logger for timing operations
local function TimedOperation()
    local startTime = debugprofilestop()
    -- ... your operation ...
    local duration = debugprofilestop() - startTime
    private.Core.Logger.debug("Performance", string.format("Operation took %.2fms", duration))
end

-- Safe function calls with error logging
local success, result = private.Core.Logger.safecall(
    function()
        -- risky operation
    end,
    "ModuleName",
    "Operation description"
)
```

### Modern Event System

#### Event Name Constants - CRITICAL PATTERN

```lua
-- ALWAYS use centralized constants to avoid string duplication and errors
local events = private.constants.events -- Use local reference for cleaner code

-- CORRECT: Use centralized constants from private.constants.events
local events = private.constants.events
private.Core.triggerEvent(events.EventSelected, eventData, "YourModule")
private.Core.registerCallback(events.CharacterSelected, callback, "YourModule")

-- WRONG: Hard-coded strings (prone to typos and maintenance issues)
-- private.Core.triggerEvent("EventSelected", eventData, "YourModule") -- DON'T DO THIS
-- private.Core.registerCallback("CharacterSelected", callback, "YourModule") -- DON'T DO THIS

-- All available event constants include:
-- - events.EventSelected
-- - events.CharacterSelected
-- - events.FactionSelected
-- - events.TimelinePeriodSelected
-- - events.TimelineInit
-- - events.UIRefresh
-- - events.SettingsEventTypeChecked
-- - events.SettingsLibraryChecked
-- And more defined in Constants.lua
```

#### Event System Integration

```lua
-- Chronicles uses a sophisticated event system with validation
-- Core events are defined in private.constants.events

-- Use local reference for cleaner code
local events = private.constants.events

-- Trigger events safely with validation
private.Core.triggerEvent(events.EventSelected, eventData, "YourModule")
private.Core.triggerEvent(events.CharacterSelected, characterData, "YourModule")
private.Core.triggerEvent(events.FactionSelected, factionData, "YourModule")

-- Register event callbacks using constants
private.Core.registerCallback(
    events.EventSelected,
    function(eventData)
        -- Handle event selection
        private.Core.Logger.info("YourModule", "Event selected: " .. eventData.label)
    end,
    "YourModule" -- Owner identifier for debugging
)

-- Event batching for performance
private.Core.EventManager.Batcher:addToBatch("myBatch", events.EventSelected, data, source)
private.Core.EventManager.Batcher:executeBatch("myBatch")

-- Plugin event registration (for extending Chronicles)
private.Core.EventManager.PluginEvents:registerPluginEvent(
    "MyPlugin",
    "CustomEvent",
    {
        description = "My custom event",
        required = {"id", "data"},
        validate = function(data)
            return data and data.id ~= nil, "Missing required ID"
        end
    }
)
```

#### Best Practice: Centralized Event Constants

```lua
-- CORRECT: Use centralized constants from private.constants.events
local events = private.constants.events
private.Core.registerCallback(events.EventSelected, callback, "Owner")

-- INCORRECT: Hardcoded strings (prone to typos and inconsistencies)
private.Core.registerCallback("Event.SELECTED", callback, "Owner") -- BAD!

-- For StateManager event listeners, always use the constants:
private.Core.StateManager.subscribe("ui.selectedEvent", callback, "Owner")
private.Core.registerCallback(events.EventSelected, function(data)
    -- Update state when event fires
    private.Core.StateManager.setState("ui.selectedEvent", data, "Event selected")
end, "StateManager")
```

These patterns ensure consistent, maintainable, and performant code that follows the actual Chronicles addon architecture using AceAddon-3.0, private namespaces, and modern event management.
