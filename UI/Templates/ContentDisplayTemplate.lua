--[[===============================================================================================
DATA STRUCTURE DOCUMENTATION FOR PagedCondensedVerticalGridContentFrameTemplate
===============================================================================================

The PagedCondensedVerticalGridContentFrameTemplate expects data in a specific nested structure 
that maintains compatibility with the old template system. This structure is generated by 
CreateUnifiedContent and processed by the template rendering system.

EXPECTED DATA STRUCTURE:
------------------------

Root Structure:
{
    [1] = {
        elements = {
            [1] = {
                templateKey = "CHAPTER_HEADER" | "HTML_CONTENT" | "TEXT_CONTENT",
                text = "string",           -- For CHAPTER_HEADER and TEXT_CONTENT
                content = "string"         -- For HTML_CONTENT
            },
            [2] = { ... },
            ...
        }
    },
    [2] = {
        elements = { ... }
    },
    ...
}

TEMPLATE KEY MAPPINGS:
----------------------

1. CHAPTER_HEADER -> ChapterHeaderTemplate -> ChapterHeaderMixin
   - Properties: text (string) - The chapter title text
   - Usage: Chapter titles, section headers, entity names
   - Rendering: Large centered text with separator line

2. HTML_CONTENT -> HtmlPageTemplate -> HtmlPageMixin  
   - Properties: content (string) - HTML formatted content
   - Usage: Rich descriptions, formatted text, entity descriptions
   - Rendering: Scrollable HTML content with proper formatting

3. TEXT_CONTENT -> ChapterLineTemplate -> ChapterLineMixin
   - Properties: text (string) - Plain text line
   - Usage: Simple text lines, individual paragraphs
   - Rendering: Single line of formatted text

ENTITY PROCESSING FLOW:
-----------------------

Input Entity:
{
    name = "Entity Name",
    description = "Entity description...",
    image = "path/to/image.tga",
    chapters = {
        {
            header = "Chapter Title",
            pages = {
                "Text content or localization key",
                "More content...",
                ...
            }
        },
        ...
    }
}

Output Structure (Generated by CreateUnifiedContent):
{
    [1] = {  -- Title section
        elements = {
            {
                templateKey = "CHAPTER_HEADER",
                text = "Entity Name"
            }
        }
    },
    [2] = {  -- Description section (if exists)
        elements = {
            {
                templateKey = "HTML_CONTENT", 
                content = "Entity description..."
            }
        }
    },
    [3] = {  -- First chapter
        elements = {
            {
                templateKey = "TEXT_CONTENT",
                text = "First line of chapter content"
            },
            {
                templateKey = "TEXT_CONTENT", 
                text = "Second line of chapter content"
            },
            ...
        },
        header = {  -- Chapter header (if exists)
            templateKey = "CHAPTER_HEADER",
            text = "Chapter Title"
        }
    },
    ...
}

TEMPLATE COMPATIBILITY NOTES:
-----------------------------

- This structure maintains backward compatibility with the old BookUtils system
- Each section has an 'elements' array containing individual UI elements
- Template keys map directly to XML template definitions and Lua mixins
- The nested structure allows the template system to iterate through sections and elements
- Old templates (ChapterHeaderTemplate, ChapterLineTemplate, HtmlPageTemplate) are restored
- Property names must match what the mixins expect ('text' vs 'content')

LOCALIZATION SUPPORT:
--------------------

- Chapter headers and page content support localization keys
- If content is a key in private.Locale, it gets replaced with localized text
- Fallback to original content if localization key not found
]]

local FOLDER_NAME, private = ...

-- Import dependencies
local StringUtils = private.Core.Utils.StringUtils

-- Initialize ContentUtils namespace
private.Core.Utils = private.Core.Utils or {}
private.Core.Utils.ContentUtils = {}
local ContentUtils = private.Core.Utils.ContentUtils

-- =============================================================================================
-- CONTENT CONVERSION UTILITIES
-- =============================================================================================

--[[
    Convert plain text content to structured HTML
    @param content [string] Plain text content
    @param portraitPath [string] Optional portrait image path
    @return [string] Formatted HTML content
]]
function ContentUtils.ConvertTextToHTML(content, portraitPath)
    local html = "<html><body>"
    if portraitPath and portraitPath ~= "" then
        html = html .. string.format('<img src="%s" width="120" height="120" align="right" style="margin: 0 0 10px 15px;" />', portraitPath)
    end
    local lines = {}
    for line in content:gmatch("[^\r\n]+") do
        line = StringUtils.Trim(line)
        if line ~= "" then
            if ContentUtils.IsChapterHeader(line) then
                table.insert(lines, string.format('<h2 style="color: #ffd100; margin-top: 20px;">%s</h2>', line))
            else
                table.insert(lines, string.format('<p style="margin-bottom: 10px; text-align: justify;">%s</p>', line))
            end
        end
    end
    html = html .. table.concat(lines, "\n") .. "</body></html>"
    return html
end

--[[
    Inject portrait into HTML content
    @param htmlContent [string] Original HTML content
    @param portraitPath [string] Portrait image path
    @return [string] HTML with integrated portrait
]]
function ContentUtils.InjectPortraitIntoHTML(htmlContent, portraitPath)
    local portraitImg = string.format('<img src="%s" width="120" height="120" align="right" style="margin: 0 0 15px 15px;" />', portraitPath)
    if htmlContent:find("<body>") then
        htmlContent = htmlContent:gsub("(<body[^>]*>)", "%1" .. portraitImg)
    else
        htmlContent = portraitImg .. htmlContent
    end
    return htmlContent
end

--[[
    Simple heuristic to detect chapter headers
    @param line [string] Text line
    @return [boolean] True if likely a chapter header
]]
function ContentUtils.IsChapterHeader(line)
    local trimmed = StringUtils.Trim(line):lower()
    return trimmed:find("^chapter") or trimmed:find("^part ") or (#trimmed < 50 and not trimmed:find("%."))
end

--[[
    Create HTML content for a complete chapter
    @param chapter [table] Chapter with header and pages  
    @return [string] Complete HTML for the chapter
]]
function ContentUtils.CreateChapterHTML(chapter)
    local html = "<html><body>"
    if chapter.header and chapter.header ~= "" then
        local headerText = chapter.header
        if private.Locale and private.Locale[chapter.header] then
            headerText = private.Locale[chapter.header]
        end
        html = html .. string.format('<h1 style="color: #ffd100; text-align: center; margin-bottom: 20px;">%s</h1>', headerText)
    end
    if chapter.pages then
        for _, pageKey in ipairs(chapter.pages) do
            local pageContent = pageKey
            if private.Locale and private.Locale[pageKey] then
                pageContent = private.Locale[pageKey]
            end
            if StringUtils.ContainsHTML and StringUtils.ContainsHTML(pageContent) then
                local cleanContent = StringUtils.CleanHTML and StringUtils.CleanHTML(pageContent) or pageContent
                html = html .. cleanContent
            else
                local paragraphs = {}
                for line in pageContent:gmatch("[^\r\n]+") do
                    line = StringUtils.Trim(line)
                    if line ~= "" then
                        table.insert(paragraphs, string.format('<p style="margin-bottom: 10px; text-align: justify;">%s</p>', line))
                    end
                end
                html = html .. table.concat(paragraphs, "\n")
            end
        end
    end
    html = html .. "</body></html>"
    return html
end

-- =============================================================================================
-- CONTENT LAYOUT UTILITIES
-- =============================================================================================

--[[
    Calculate optimal content dimensions and pagination
    @param content [string] Raw content (HTML or text)
    @param maxWidth [number] Maximum width in pixels
    @param maxHeight [number] Maximum height in pixels (optional)
    @param portraitPath [string] Optional portrait image path
    @return [table] {pages = {}, estimatedHeight = number, hasPortrait = boolean}
]]
function ContentUtils.CalculateContentLayout(content, maxWidth, maxHeight, portraitPath)
    local result = {
        pages = {},
        estimatedHeight = 0,
        hasPortrait = portraitPath and portraitPath ~= ""
    }
    local isHTML = StringUtils.ContainsHTML and StringUtils.ContainsHTML(content) or string.find(content, "<[^>]+>") ~= nil
    if isHTML then
        result.pages = ContentUtils.SplitHTMLContent(content, maxWidth, maxHeight, portraitPath)
    else
        local htmlContent = ContentUtils.ConvertTextToHTML(content, portraitPath)
        result.pages = {htmlContent}
    end
    result.estimatedHeight = #result.pages * (maxHeight or 400)
    return result
end

--[[
    Split HTML content into manageable pages
    @param content [string] HTML content
    @param maxWidth [number] Maximum width
    @param maxHeight [number] Maximum height
    @param portraitPath [string] Portrait path
    @return [table] Array of HTML page strings
]]
function ContentUtils.SplitHTMLContent(content, maxWidth, maxHeight, portraitPath)
    local pages = {}
    local cleanContent = StringUtils.CleanHTML and StringUtils.CleanHTML(content) or content
    if portraitPath and portraitPath ~= "" and not cleanContent:find("<img[^>]*src=") then
        cleanContent = ContentUtils.InjectPortraitIntoHTML(cleanContent, portraitPath)
    end
    table.insert(pages, cleanContent)
    return pages
end

-- =============================================================================================
-- CONTENT STRUCTURE CREATION UTILITIES
-- =============================================================================================

--[[
    Create unified content data for book display
    @param entity [table] Entity with chapters and description
    @return [table] Unified content structure compatible with existing templates
]]
function ContentUtils.CreateUnifiedContent(entity)
    if not entity then return {} end
    local data = {}
    local titleElement = {
        templateKey = private.constants.bookTemplateKeys.CHAPTER_HEADER,
        text = entity.name or entity.label or "Unknown Entity"
    }
    table.insert(data, { elements = {titleElement} })
    if entity.description and entity.description ~= "" then
        local descElement = {
            templateKey = private.constants.bookTemplateKeys.HTML_CONTENT,
            content = entity.description
        }
        table.insert(data, { elements = {descElement} })
    end
    if entity.chapters and #entity.chapters > 0 then
        for _, chapter in ipairs(entity.chapters) do
            local bookChapter = ContentUtils.CreateChapterInOldFormat(chapter)
            table.insert(data, bookChapter)
        end
    end
    return data
end

--[[
    Create a chapter in the old nested format for compatibility
    @param chapter [table] Chapter with header and pages
    @return [table] Chapter object with header and elements array
]]
function ContentUtils.CreateChapterInOldFormat(chapter)
    local bookChapter = {elements = {}}
    if chapter.header and chapter.header ~= "" then
        local headerText = chapter.header
        if private.Locale and private.Locale[chapter.header] then
            headerText = private.Locale[chapter.header]
        end
        bookChapter.header = {
            templateKey = private.constants.bookTemplateKeys.CHAPTER_HEADER,
            text = headerText
        }
    end
    if chapter.pages then
        for _, pageKey in ipairs(chapter.pages) do
            local pageContent = pageKey
            if private.Locale and private.Locale[pageKey] then
                pageContent = private.Locale[pageKey]
            end
            if StringUtils.ContainsHTML and StringUtils.ContainsHTML(pageContent) then
                table.insert(bookChapter.elements, {
                    templateKey = private.constants.bookTemplateKeys.HTML_CONTENT,
                    content = StringUtils.CleanHTML and StringUtils.CleanHTML(pageContent) or pageContent
                })
            else
                local lines
                if StringUtils and StringUtils.SplitTextToFitWidth then
                    lines = StringUtils.SplitTextToFitWidth(pageContent, private.constants.viewWidth)
                else
                    lines = {pageContent}
                end
                for _, line in ipairs(lines) do
                    table.insert(bookChapter.elements, {
                        templateKey = private.constants.bookTemplateKeys.TEXT_CONTENT,
                        text = line
                    })
                end
            end
        end
    end
    return bookChapter
end

-- =============================================================================================
-- UI MIXINS
-- =============================================================================================

--[[
    Mixin for unified content display components
]]
UnifiedContentMixin = {}

--[[
    Initialize unified content display
    @param elementData [table] Element data with content and formatting options
]]
function UnifiedContentMixin:Init(elementData)
    if not elementData then
        return
    end

    local htmlContent = ""

    if elementData.htmlContent then
        htmlContent = elementData.htmlContent
    elseif elementData.text then
        htmlContent = ContentUtils.ConvertTextToHTML(elementData.text, elementData.portraitPath)
    end

    if htmlContent ~= "" and self.ScrollFrame and self.ScrollFrame.HTML then
        local parentWidth = self:GetParent() and self:GetParent():GetWidth() or 400
        local contentWidth = math.max(parentWidth - 40, 300) -- Account for padding and scrollbar

        self.ScrollFrame.HTML:SetSize(contentWidth, 1)
        self.ScrollFrame.HTML:SetText(htmlContent)

        local estimatedHeight = elementData.estimatedHeight or 400
        self:SetHeight(estimatedHeight)
    end
end

--[[
    Mixin for content scroll frame components
]]
ContentScrollFrameMixin = {}

--[[
    Initialize scroll frame with scrollbar support
]]
function ContentScrollFrameMixin:OnLoad()
    if not self.noScrollBar then
        local scrollBarTemplate = self.scrollBarTemplate or "MinimalScrollBar"

        local left = self.scrollBarX or 14
        local top = self.scrollBarTopY or -5
        local bottom = self.scrollBarBottomY or 5

        local scrollBar = CreateFrame("EventFrame", nil, self, scrollBarTemplate)
        scrollBar:SetPoint("TOPLEFT", self, "TOPRIGHT", left, top)
        scrollBar:SetPoint("BOTTOMLEFT", self, "BOTTOMRIGHT", left, bottom)

        self.ScrollBar = scrollBar

        local function updateScrollBar()
            local scrollRange = self:GetVerticalScrollRange()
            local scrollOffset = self:GetVerticalScroll()

            if scrollRange > 0 then
                local scrollPercentage = scrollOffset / scrollRange
                scrollBar:SetScrollPercentage(scrollPercentage, ScrollBoxConstants.NoScrollInterpolation)

                local visibleExtent = self:GetHeight() / (scrollRange + self:GetHeight())
                scrollBar:SetVisibleExtentPercentage(visibleExtent)
            end
        end

        self:SetScript("OnVerticalScroll", updateScrollBar)
        self:SetScript("OnScrollRangeChanged", updateScrollBar)

        if self.scrollOnMouse then
            self:SetScript(
                "OnMouseWheel",
                function(_, delta)
                    scrollBar:ScrollStepInDirection(-delta)
                end
            )
        end

        scrollBar:RegisterCallback(
            BaseScrollBoxEvents.OnScroll,
            function(_, scrollPercentage)
                local scroll = scrollPercentage * self:GetVerticalScrollRange()
                self:SetVerticalScroll(scroll)
            end
        )
    end
end

--[[
    Mixin for cover with content display
]]
CoverWithContentMixin = {}

--[[
    Initialize cover display with entity information
    @param elementData [table] Element data containing entity information
]]
function CoverWithContentMixin:Init(elementData)
    if not elementData or not elementData.entity then
        return
    end

    local entity = elementData.entity

    if entity.name or entity.label then
        if self.Name then
            self.Name:SetText(entity.name or entity.label)
        end
    end

    if entity.author and entity.author ~= "" then
        if self.Author then
            self.Author:SetText("Author: " .. entity.author)
            self.Author:Show()
        end
    else
        if self.Author then
            self.Author:Hide()
        end
    end

    local htmlContent = ""
    if entity.description then
        htmlContent = ContentUtils.ConvertTextToHTML(entity.description, elementData.portraitPath)
    end

    if self.ContentFrame and htmlContent ~= "" then
        self.ContentFrame:Init(
            {
                htmlContent = htmlContent,
                portraitPath = elementData.portraitPath,
                estimatedHeight = 300
            }
        )
    end
end

--[[
    Mixin for page break elements
]]
PageBreakMixin = {}

--[[
    Initialize page break element
    @param elementData [table] Element data for page break configuration
]]
function PageBreakMixin:Init(elementData)
    -- Simple page break - could be enhanced with page numbers
end
